WITH REFERENCE_DATES AS (
    SELECT SYSDATE - {CHURN_THRESHOLD} AS CHURN_CUTOFF_DATE FROM DUAL
),
FILTERED_TRANSACTIONS AS (
    -- Preselect only the rows meeting the common conditions.
    SELECT trx.*
    FROM {SCHEMA_NAME}.TRANSACTION_MAIN trx
    CROSS JOIN (SELECT SYSDATE - {CHURN_THRESHOLD} AS CHURN_CUTOFF_DATE FROM DUAL) ref
    WHERE trx.IS_DELETED = 0
      AND trx.TRX_STATE_ID IN (1, 3)
      AND trx.AMOUNT_AFTER_DISCOUNT is not null
      -- Using the computed cutoff directly to avoid the extra join:
      AND trx.TRANSACTION_DATE < ref.CHURN_CUTOFF_DATE
),
CUSTOMER_BASE AS (
    /*+ MATERIALIZE */
    SELECT
        cust.UNIQUE_CUSTOMER_ID,
        cust.FIRM_ID,
        trx.PROGRAM_ID,
        prg.PROGRAM_NAME,
        MIN(trx.TRANSACTION_DATE) AS FIRST_TRANSACTION_DATE,
        MAX(trx.TRANSACTION_DATE) AS LAST_TRANSACTION_BEFORE_CUTOFF,
        COUNT(trx.TRANSACTION_ID) AS TOTAL_TRANSACTIONS,
        SUM(trx.AMOUNT_AFTER_DISCOUNT) AS TOTAL_SPENT,
        AVG(trx.AMOUNT_AFTER_DISCOUNT) AS AVG_SPENT,
        MAX(trx.AMOUNT_AFTER_DISCOUNT) AS MAX_SPENT,
        MIN(trx.AMOUNT_AFTER_DISCOUNT) AS MIN_SPENT,
        (SELECT CHURN_CUTOFF_DATE FROM REFERENCE_DATES) - MAX(trx.TRANSACTION_DATE) AS DAYS_SINCE_LAST_TRANSACTION,
        (MAX(trx.TRANSACTION_DATE) - MIN(trx.TRANSACTION_DATE)) AS CUSTOMER_LIFETIME
    FROM {SCHEMA_NAME}.CUSTOMER_STG cust
    INNER JOIN FILTERED_TRANSACTIONS trx
        ON cust.CUSTOMER_ID = trx.CUSTOMER_ID
   	LEFT JOIN {SCHEMA_NAME}.DIM_PROGRAM prg 
   		ON trx.PROGRAM_ID = prg.PROGRAM_ID 
    CROSS JOIN REFERENCE_DATES ref
    WHERE cust.IS_DELETED = 0
    GROUP BY cust.UNIQUE_CUSTOMER_ID, cust.FIRM_ID, trx.PROGRAM_ID, prg.PROGRAM_NAME 
    HAVING COUNT(trx.TRANSACTION_ID) > 3
       AND SUM(trx.AMOUNT_AFTER_DISCOUNT) > 100
),
POST_CUTOFF_ACTIVITY AS (
    SELECT
        trx.CUSTOMER_ID,
        trx.PROGRAM_ID,
        COUNT(trx.TRANSACTION_ID) AS TRANSACTIONS_AFTER_CUTOFF
    FROM (
         SELECT *
         FROM {SCHEMA_NAME}.TRANSACTION_MAIN trx
         WHERE trx.IS_DELETED = 0
           AND trx.TRX_STATE_ID IN (1,3)
           AND trx.TRANSACTION_DATE >= (SELECT CHURN_CUTOFF_DATE FROM REFERENCE_DATES)
    ) trx
    GROUP BY trx.CUSTOMER_ID, trx.PROGRAM_ID 
),
TRANSACTION_DATES AS (
    SELECT
        trx.CUSTOMER_ID,
        trx.PROGRAM_ID, 
        trx.TRANSACTION_DATE,
        trx.AMOUNT_AFTER_DISCOUNT,
        trx.AMOUNT_DISCOUNT,
        trx.AMOUNT_USED_POINT,
        trx.AMOUNT_EARNED_POINT,
        LAG(trx.TRANSACTION_DATE) OVER (PARTITION BY trx.CUSTOMER_ID ORDER BY trx.TRANSACTION_DATE) AS PREVIOUS_TRANSACTION_DATE
    FROM FILTERED_TRANSACTIONS trx
),
TRANSACTION_FEATURES AS (
    SELECT
        td.CUSTOMER_ID,
        td.PROGRAM_ID,
        COUNT(td.TRANSACTION_DATE) AS DISTINCT_TRANSACTIONS,
        AVG(td.TRANSACTION_DATE - td.PREVIOUS_TRANSACTION_DATE) AS AVG_DAYS_BETWEEN_TRANSACTIONS,
        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY td.AMOUNT_AFTER_DISCOUNT) AS MEDIAN_BASKET_SIZE,
        STDDEV(td.AMOUNT_AFTER_DISCOUNT) AS BASKET_SIZE_STDDEV,
        SUM(CASE WHEN td.AMOUNT_AFTER_DISCOUNT > 0 THEN td.AMOUNT_AFTER_DISCOUNT ELSE 0 END) AS TOTAL_SPENT_IN_TRANSACTIONS,
        SUM(CASE WHEN td.AMOUNT_DISCOUNT > 0 THEN td.AMOUNT_DISCOUNT ELSE 0 END) AS TOTAL_DISCOUNT_EARNED,
        SUM(CASE WHEN td.AMOUNT_USED_POINT > 0 THEN td.AMOUNT_USED_POINT ELSE 0 END) AS TOTAL_USED_POINT,
        SUM(CASE WHEN td.AMOUNT_EARNED_POINT > 0 THEN td.AMOUNT_EARNED_POINT ELSE 0 END) AS TOTAL_EARNED_POINT,
        COUNT(CASE WHEN td.AMOUNT_DISCOUNT > 0 THEN 1 ELSE NULL END) AS DISCOUNTED_TRANSACTIONS,
        COUNT(CASE WHEN td.AMOUNT_USED_POINT > 0 THEN 1 ELSE NULL END) AS POINT_USED_TRANSACTIONS
    FROM TRANSACTION_DATES td
    GROUP BY td.CUSTOMER_ID, td.PROGRAM_ID 
),
CHURN_DATASET AS (
    SELECT
        base.UNIQUE_CUSTOMER_ID,
        base.PROGRAM_ID,
        base.PROGRAM_NAME,
        base.FIRM_ID,
        base.FIRST_TRANSACTION_DATE,
        base.LAST_TRANSACTION_BEFORE_CUTOFF,
        base.TOTAL_TRANSACTIONS,
        base.TOTAL_SPENT,
        base.AVG_SPENT,
        base.MAX_SPENT,
        base.MIN_SPENT,
        base.DAYS_SINCE_LAST_TRANSACTION,
        base.CUSTOMER_LIFETIME,
        COALESCE(post.TRANSACTIONS_AFTER_CUTOFF, 0) AS TRANSACTIONS_AFTER_CUTOFF,
        CASE
            WHEN COALESCE(post.TRANSACTIONS_AFTER_CUTOFF, 0) = 0 THEN 1
            ELSE 0
        END AS IS_CHURN,
        trx_features.DISTINCT_TRANSACTIONS,
        trx_features.AVG_DAYS_BETWEEN_TRANSACTIONS,
        trx_features.MEDIAN_BASKET_SIZE,
        trx_features.BASKET_SIZE_STDDEV,
        trx_features.TOTAL_DISCOUNT_EARNED,
        trx_features.DISCOUNTED_TRANSACTIONS,
        trx_features.TOTAL_USED_POINT,
        trx_features.TOTAL_EARNED_POINT,
        trx_features.POINT_USED_TRANSACTIONS
    FROM CUSTOMER_BASE base
    LEFT JOIN TRANSACTION_FEATURES trx_features
        ON base.UNIQUE_CUSTOMER_ID = trx_features.CUSTOMER_ID AND base.PROGRAM_ID  = trx_features.PROGRAM_ID 
    LEFT JOIN POST_CUTOFF_ACTIVITY post
        ON base.UNIQUE_CUSTOMER_ID = post.CUSTOMER_ID AND base.PROGRAM_ID  = post.PROGRAM_ID 
)

SELECT *
FROM (
    SELECT t.*, DBMS_RANDOM.VALUE as rnd
    FROM CHURN_DATASET t
    WHERE (IS_CHURN = 0)
       OR (IS_CHURN = 1 AND DAYS_SINCE_LAST_TRANSACTION <= {CHURN_THRESHOLD})
    ORDER BY DBMS_RANDOM.VALUE
)
WHERE ROWNUM <= 500000
